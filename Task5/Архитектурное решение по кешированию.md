# Архитектурное решение по кешированию

## 1. Мотивация

Основные проблемы MES:
- Долгая загрузка дашборда с заказами даже после внедрения пагинации и фильтров.
- Пользователи жалуются на скорость отображения заказов.
- Процесс расчёта стоимости заказа занимает до 30 минут.

Причины:
- Запросы к базе данных MES выполняются медленно (нет индексов, запросы сложные).
- Нет кеширования часто используемых данных (списки заказов, статусы).
- Каждое обращение идёт напрямую в базу.

**Что мы хотим решить:**
- Ускорить отображение списка заказов и деталей по заказам.
- Снизить нагрузку на базу MES.
- Сократить время обработки массовых запросов.

**Элементы для кеширования:**
- Список заказов на дашборде MES.
- Детали заказа (метаданные: статус, дата создания, стоимость, исполнитель).
- Результаты расчёта стоимости (для одинаковых моделей, чтобы не пересчитывать повторно).

---

## 2. Предлагаемое решение

Мы будем внедрять **серверное кеширование**.

### Почему серверное кеширование?
- Проблема находится на стороне API и БД, а не у клиентов.
- Пользователи (операторы) работают через разные браузеры и устройства → кешировать только на клиенте неэффективно.
- Серверный кеш позволит централизованно контролировать данные и синхронизацию.

### Паттерн кеширования: **Cache-Aside**
- Данные читаются из кеша, если они там есть.
- Если данных нет, они берутся из БД, кладутся в кеш и возвращаются клиенту.
- Этот паттерн гибкий и хорошо подходит для постепенного внедрения.

**Почему не Write-Through?**
- Повысится нагрузка на кеш при каждой записи.
- Для MES операции записи относительно редкие (подтверждение или завершение заказа), а операции чтения — массовые.

**Почему не Refresh-Ahead?**
- Подходит для прогнозируемых и однотипных данных (например, каталога товаров).
- Для заказов предсказать загрузку и время обновления сложно.

---

## 3. Диаграмма последовательности

### 3.1 Чтение списка заказов
Диаграмма: Task5/diagram/order.puml
### 3.2 Изменение статуса заказа
Диаграмма:Task5/diagram/status.puml

## 4. Стратегия инвалидации кеша

Мы используем **инвалидацию по ключу**:
- При изменении статуса заказа → инвалидируем ключ `order_<id>` и список `orders_list`.
- Для списков (дашборд) используем **TTL 5 минут**, чтобы периодически обновлять данные.

**Почему не временная (только TTL)?**
- При изменении статуса заказ будет отображаться неправильно до истечения TTL.

**Почему не только программная?**
- Программная требует строгого контроля всех операций, а TTL добавляет подстраховку.

### Сравнительный анализ стратегий

| Стратегия              | Плюсы                               | Минусы |
|-------------------------|-------------------------------------|--------|
| TTL (временная)         | Простая реализация, защита от «забытых» ключей | Возможна устаревшая информация |
| По ключу (программная)  | Всегда актуальные данные            | Нужно тщательно продумать логику |
| Комбинированная (наш выбор) | Баланс между актуальностью и простотой | Более сложная реализация |

---

## 5. Альтернативные решения

### Решение 1: Cache-Aside с Redis (наш выбор)
- Плюсы: простое внедрение, гибкость, снижение нагрузки на БД.
- Минусы: возможны задержки при первом обращении.

### Решение 2: Write-Through
- Плюсы: кеш всегда синхронизирован с БД.
- Минусы: лишняя нагрузка на кеш при каждой записи, не решает проблему с редкими изменениями.

---

## 6. Заключение

Для MES критично ускорить работу с дашбордом заказов и деталями заказов.  
Оптимальным решением является внедрение **серверного кеширования по паттерну Cache-Aside** с Redis,  
с комбинированной стратегией инвалидации (по ключу + TTL).

Это даст:
- Сокращение времени загрузки дашборда (с секунд/десятков секунд до миллисекунд при кеш-хите).
- Снижение нагрузки на базу MES.
- Удовлетворение операторов и новых клиентов.  
