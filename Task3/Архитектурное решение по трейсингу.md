# Архитектурное решение по трейсингу

## 1. Мотивация

В текущей системе заказы часто оказываются в непонятном состоянии:
- теряются сообщения в очередях RabbitMQ,
- застревают при переходе между CRM, MES и Shop API,
- длительное время, остаются в промежуточных статусах.

Это приводит к жалобам клиентов и отсутствию прозрачности для бизнеса.

Внедрение распределённого трейсинга позволит:
- видеть полный путь заказа через все подсистемы,
- находить точку, где заказ «сломался» или завис,
- сократить время расследования инцидентов,
- повысить доверие бизнеса и клиентов.  

**Метрики, на которые повлияет внедрение:**
1. MTTR (среднее время восстановления после инцидента) ↓.
2. SLA по обработке заказов ↑.
3. Количество потерянных/подвисших заказов ↓.
4. Скорость выпуска фич (так как разработчики быстрее находят узкие места) ↑.  

## 2. Системы, которые должны быть покрыты трейсингом

На диаграмме нужно покрыть трейсингом:
- **Shop API** — создание заказа, загрузка файлов, SUBMITTED → INITIATED.
- **CRM API** — подтверждение заказа (MANUFACTURING_APPROVED).
- **MES API** — расчёт стоимости, начало/окончание производства.
- **RabbitMQ** — отправка/получение сообщений.
- **Базы данных (Shop DB, MES DB)** — запись/чтение статусов заказа.
- **3D Files Storage** — загрузка/доступ к файлам.  

## 3. Данные, которые должны попадать в трейсинг

- **trace_id** и **span_id** (сквозные идентификаторы через все сервисы).
- Идентификатор заказа (order_id).
- Статус заказа.
- Время начала и завершения каждой операции.
- Код ответа (успешно/ошибка).
- Информация о пользователе/партнёре (например, `partner_id`).
- Размер и тип загруженного файла (для 3D storage).  


## 4. Предлагаемое решение

### Технологии
- **OpenTelemetry SDK** во всех сервисах (Java, C#, Node.js, Vue/React).
- **Jaeger или Tempo (Grafana)** как бэкенд для хранения и анализа трейсинга.
- **Prometheus + Grafana** интеграция для построения алертов и дашбордов.
- **Middleware** в API для автоматической прокрутки trace_id в RabbitMQ и HTTP-запросах.

### Новые компоненты
- Collector (OpenTelemetry Collector) — сбор данных от сервисов.
- Tracing backend (Jaeger/Tempo).
- Панели в Grafana для визуализации трейсинга.

### Доработки на диаграмме
- Добавить компонент **Tracing Collector** (красным).
- Добавить связи от Shop API, CRM API, MES API, RabbitMQ, DB к Collector.
- Добавить компонент **Tracing Storage & UI (Jaeger/Tempo)** (красным).

**Ссылка на диаграмму с обновлениями:**  
Диаграмма: Task3/diagram/tracing.puml.  


## 5. Компромиссы

- Внедрение в проприетарные части (например, внешние API) может быть невозможно.
- Нагрузка на систему от трейсинга (дополнительные логи и метаданные).
- Хранение трейсингов требует выделенного объёма (дороже).
- Не имеет смысла внедрять трейсинг в простые статические компоненты (например, фронтенд без логики).


## 6. Аспекты безопасности

- Доступ к системе трейсинга только для сотрудников с ролью «Support/DevOps».
- Авторизация через корпоративный SSO.
- Маскирование персональных данных (PII) при логировании.


## 7. Автоматический мониторинг и алертинг 

На базе данных трейсинга можно построить:
- автоматический алерт, если заказ находится в статусе > N минут,
- алерт, если сообщение в очереди RabbitMQ не подтверждается,
- алерт, если расчёт стоимости в MES занимает > X минут.

### Доработки на диаграмме
- Добавить компонент **Alertmanager** (зелёным).
- Добавить связь от Tracing Collector к Alertmanager.
- Добавить связь от Alertmanager к DevOps/Support.
  **Ссылка на диаграмму с обновлениями:**  
  Task3/diagramma/tracing.puml.  
